<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Weather Data Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family:  'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background:  linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #canvas-container {
            width: 100%;
            height:  100%;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            z-index:  100;
        }
        
        #controls h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
        }
        
        .control-group select,
        .control-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size:  14px;
        }
        
        button {
            width: 100%;
            padding:  10px;
            background:  #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius:  10px;
            box-shadow:  0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            color: #666;
            z-index: 100;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 50px;
            border-radius:  10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 18px;
            color: #667eea;
            z-index: 200;
        }
        
        .hidden {
            display: none;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius:  10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            z-index: 100;
        }
        
        #stats h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        
        .stat-label {
            color: #666;
        }
        
        .stat-value {
            font-weight:  bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Lade Daten...</div>
        
        <div id="controls" class="hidden">
            <h2>üéõÔ∏è Steuerung</h2>
            
            <div class="control-group">
                <label for="timeRange">Zeitraum (Stunden):</label>
                <select id="timeRange">
                    <option value="6">6 Stunden</option>
                    <option value="12">12 Stunden</option>
                    <option value="24" selected>24 Stunden</option>
                    <option value="48">48 Stunden</option>
                    <option value="168">7 Tage</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="visualizationType">Visualisierungstyp:</label>
                <select id="visualizationType">
                    <option value="bars">3D Balken</option>
                    <option value="spheres">Sph√§ren</option>
                    <option value="lines">Linien</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="dataType">Datenpunkt: </label>
                <select id="dataType">
                    <option value="temperature">Temperatur</option>
                    <option value="humidity">Luftfeuchtigkeit</option>
                    <option value="gasval">Gaswert</option>
                </select>
            </div>
            
            <button onclick="loadData()">üîÑ Daten neu laden</button>
        </div>
        
        <div id="stats" class="hidden">
            <h3>üìä Statistik</h3>
            <div class="stat-item">
                <span class="stat-label">Sender: </span>
                <span class="stat-value" id="senderCount">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Datenpunkte:</span>
                <span class="stat-value" id="dataPointCount">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Zeitraum:</span>
                <span class="stat-value" id="timeRangeDisplay">-</span>
            </div>
        </div>
        
        <div id="canvas-container"></div>
        
        <div id="info" class="hidden">
            üñ±Ô∏è Maus:  Rotieren | üéØ Rechtsklick: Bewegen | üîç Scroll: Zoom
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let currentData = null;
        
        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 50, 200);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x667eea, 1, 100);
            pointLight.position. set(0, 20, 0);
            scene. add(pointLight);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x667eea, 0x333333);
            scene.add(gridHelper);
            
            // Axes helper
            const axesHelper = new THREE.AxesHelper(30);
            scene.add(axesHelper);
            
            // Simple orbit controls (mouse-based)
            setupControls();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        // Simple orbit controls
        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                
                camera.position.x = camera.position.x * Math.cos(deltaX * rotationSpeed) 
                                   - camera.position.z * Math.sin(deltaX * rotationSpeed);
                camera. position.z = camera.position.z * Math.cos(deltaX * rotationSpeed) 
                                   + camera.position.x * Math.sin(deltaX * rotationSpeed);
                
                camera.lookAt(0, 0, 0);
                
                previousMousePosition = { x:  e.clientX, y: e.clientY };
            });
            
            renderer.domElement. addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;
                
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Load data from API
        async function loadData() {
            const hours = document.getElementById('timeRange').value;
            document.getElementById('loading').classList.remove('hidden');
            
            try {
                const response = await fetch(`/api/weather/visualization/data?hours=${hours}`);
                const data = await response. json();
                
                currentData = data;
                updateStats(data);
                visualizeData(data);
                
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('controls').classList.remove('hidden');
                document.getElementById('stats').classList.remove('hidden');
                document.getElementById('info').classList.remove('hidden');
                
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Fehler beim Laden der Daten: ' + error. message);
                document.getElementById('loading').classList.add('hidden');
            }
        }
        
        function updateStats(data) {
            document.getElementById('senderCount').textContent = data.totalSenders;
            document.getElementById('dataPointCount').textContent = data.totalDataPoints;
            document.getElementById('timeRangeDisplay').textContent = data.hours + 'h';
        }
        
        function visualizeData(data) {
            // Clear previous visualization
            while(scene.children.length > 0) { 
                const object = scene.children[0];
                if (object.geometry) object.geometry.dispose();
                if (object.material) object.material.dispose();
                scene.remove(object);
            }
            
            // Re-add lights and helpers
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight. position.set(50, 50, 50);
            scene.add(directionalLight);
            
            const gridHelper = new THREE.GridHelper(100, 50, 0x667eea, 0x333333);
            scene.add(gridHelper);
            
            const axesHelper = new THREE. AxesHelper(30);
            scene.add(axesHelper);
            
            // Get visualization settings
            const vizType = document.getElementById('visualizationType').value;
            const dataType = document.getElementById('dataType').value;
            
            // Create visualization
            const senders = data.senders;
            const senderSpacing = 15;
            
            senders.forEach((sender, senderIndex) => {
                const dataPoints = sender.dataPoints;
                const xOffset = (senderIndex - senders.length / 2) * senderSpacing;
                
                // Add sender label
                const labelCanvas = document.createElement('canvas');
                const context = labelCanvas.getContext('2d');
                context.font = 'Bold 48px Arial';
                context.fillStyle = 'white';
                context.fillText(sender.sender. name, 0, 48);
                
                const texture = new THREE.CanvasTexture(labelCanvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE. Sprite(spriteMaterial);
                sprite.position.set(xOffset, -5, 0);
                sprite. scale.set(10, 5, 1);
                scene.add(sprite);
                
                // Visualize data points
                const recentPoints = dataPoints.slice(-50); // Last 50 points
                
                recentPoints.forEach((point, pointIndex) => {
                    const value = point[dataType] || 0;
                    const zPosition = (pointIndex - recentPoints.length / 2) * 0.5;
                    
                    let object;
                    
                    if (vizType === 'bars') {
                        const height = Math.max(value * 0.5, 0.1);
                        const geometry = new THREE.BoxGeometry(1, height, 0.3);
                        const material = new THREE.MeshPhongMaterial({
                            color: getColorForValue(value, dataType),
                            emissive: getColorForValue(value, dataType),
                            emissiveIntensity: 0.2
                        });
                        object = new THREE.Mesh(geometry, material);
                        object. position.set(xOffset, height / 2, zPosition);
                        
                    } else if (vizType === 'spheres') {
                        const radius = Math.max(value * 0.05, 0.2);
                        const geometry = new THREE.SphereGeometry(radius, 16, 16);
                        const material = new THREE.MeshPhongMaterial({
                            color: getColorForValue(value, dataType),
                            emissive: getColorForValue(value, dataType),
                            emissiveIntensity: 0.3
                        });
                        object = new THREE.Mesh(geometry, material);
                        object. position.set(xOffset, value * 0.3, zPosition);
                        
                    } else if (vizType === 'lines') {
                        if (pointIndex > 0) {
                            const prevPoint = recentPoints[pointIndex - 1];
                            const prevValue = prevPoint[dataType] || 0;
                            const prevZ = (pointIndex - 1 - recentPoints.length / 2) * 0.5;
                            
                            const points = [];
                            points.push(new THREE.Vector3(xOffset, prevValue * 0.3, prevZ));
                            points.push(new THREE.Vector3(xOffset, value * 0.3, zPosition));
                            
                            const geometry = new THREE. BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({
                                color: getColorForValue(value, dataType),
                                linewidth: 2
                            });
                            object = new THREE.Line(geometry, material);
                        }
                    }
                    
                    if (object) {
                        object.castShadow = true;
                        object.receiveShadow = true;
                        scene.add(object);
                    }
                });
            });
        }
        
        function getColorForValue(value, dataType) {
            if (dataType === 'temperature') {
                // Blue (cold) to Red (hot)
                const normalized = Math.max(0, Math.min(1, (value - 0) / 40));
                return new THREE.Color(normalized, 0.2, 1 - normalized);
            } else if (dataType === 'humidity') {
                // Light to dark blue
                const normalized = Math.max(0, Math.min(1, value / 100));
                return new THREE.Color(0.2, 0.5 + normalized * 0.5, 1);
            } else {
                // Green gradient
                const normalized = Math.max(0, Math.min(1, value / 1000));
                return new THREE. Color(normalized, 1 - normalized * 0.5, 0.3);
            }
        }
        
        // Event listeners
        document.getElementById('timeRange').addEventListener('change', loadData);
        document.getElementById('visualizationType').addEventListener('change', () => {
            if (currentData) visualizeData(currentData);
        });
        document.getElementById('dataType').addEventListener('change', () => {
            if (currentData) visualizeData(currentData);
        });
        
        // Initialize
        initScene();
        loadData();
    </script>
</body>
</html>