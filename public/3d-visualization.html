<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interaktive 3D-Visualisierung der Wetterdaten vom Werner-Heisenberg-Gymnasium Leverkusen. Zeigt Temperatur, Luftfeuchtigkeit und Luftdruck in Echtzeit.">
    <meta name="keywords" content="Wetterstation, 3D Visualisierung, Werner-Heisenberg-Gymnasium, Wetterdaten, Temperatur, Luftfeuchtigkeit, Three.js">
    <meta name="author" content="WHG-Dev Team">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="3D Wetterstation Visualisierung - WHG Leverkusen">
    <meta property="og:description" content="Interaktive 3D-Visualisierung der Wetterdaten vom Werner-Heisenberg-Gymnasium">
    <meta property="og:site_name" content="WHG Wetterstation">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="3D Wetterstation Visualisierung - WHG Leverkusen">
    <meta name="twitter:description" content="Interaktive 3D-Visualisierung der Wetterdaten vom Werner-Heisenberg-Gymnasium">
    
    <title>3D Visualisierung - WHG Wetterstation</title>
    <style>
        * {
            color: white;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, Helvetica, sans-serif;
            background-color: #253949;
            overflow: hidden;
        }

        main#container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        section#canvas-container {
            width: 100%;
            height: 100%;
        }

        /* Header angepasst an Website-Design */
        header#header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background-color: rgba(37, 57, 73, 0.15);
            backdrop-filter: blur(3.8vh);
            border-bottom: 0.15vh solid white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2vw;
            z-index: 1000;
        }

        .header-left,
        .header-right {
            flex: 1;
        }

        .header-center {
            flex: 2;
            text-align: center;
        }

        .header-center h1 {
            margin: 0;
            font-size: 4vw;
            color: white;
            font-family: Arial, Helvetica, sans-serif;
            transition: font-size 100ms ease-in-out;
        }

        .header-center h1:hover {
            font-size: 4.1vw;
        }

        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 1vh 2vw;
            background: none;
            color: white;
            text-decoration: none;
            border-radius: 25px;
            border: 0.15vh solid white;
            font-size: 1.7vw;
            font-weight: normal;
            transition: transform 100ms ease-in-out;
        }

        .back-button:hover {
            transform: scale(1.01);
        }
        
        /* Controls-Panel - KOMPAKT */
        aside#controls {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 20vw;
            min-width: 250px;
            min-height: 200px;
            border-radius: 3.8vh;
            border: 0.15vh solid white;
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(3.8vh);
            padding: 15px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            z-index: 100;
            transition: transform 100ms ease-in-out;
        }

        aside#controls:hover {
            transform: scale(1.01);
        }
        
        aside#controls h2 {
            margin-bottom: 12px;
            color: white;
            font-size: 2.2vw;
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: white;
            font-size: 1.2vw;
            font-weight: normal;
        }
        
        /* ESP-Selector-Stil √ºbernommen */
        .control-group select {
            width: 100%;
            padding: 0.8vh;
            color: grey;
            background-color: white;
            border: none;
            border-radius: 25px;
            font-size: 1.3vw;
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
            outline: none;
        }

        .control-group select:hover {
            background-color: #f0f0f0;
        }
        
        button {
            width: 100%;
            padding: 1.2vh;
            background-color: white;
            color: grey;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.4vw;
            font-family: Arial, Helvetica, sans-serif;
            font-weight: normal;
            transition: background-color 200ms ease-in-out;
        }
        
        button:hover {
            background-color: #f0f0f0;
        }
        
        /* Stats-Box - auch kompakter */
        aside#stats {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 20vw;
            min-width: 250px;
            border-radius: 3.8vh;
            border: 0.15vh solid white;
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(3.8vh);
            padding: 15px;
            z-index: 100;
            transition: transform 100ms ease-in-out;
        }

        aside#stats:hover {
            transform: scale(1.01);
        }
        
        aside#stats h3 {
            margin-bottom: 12px;
            color: white;
            font-size: 1.8vw;
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 0.15vh solid rgba(255, 255, 255, 0.3);
            font-size: 1.2vw;
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: white;
        }
        
        .stat-value {
            font-weight: bold;
            color: white;
        }

        .info-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 0.15vh solid rgba(255, 255, 255, 0.3);
        }

        .info-section small {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1vw;
            display: block;
            text-align: center;
        }

        /* Info-Box unten */
        aside#info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(3.8vh);
            border: 0.15vh solid white;
            border-radius: 3.8vh;
            padding: 15px 20px;
            font-size: 1.4vw;
            color: white;
            z-index: 100;
        }
        
        /* Tooltip */
        #tooltip {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(3.8vh);
            border: 0.15vh solid white;
            border-radius: 2vh;
            padding: 10px 15px;
            font-size: 1.3vw;
            color: #253949;
            z-index: 150;
            pointer-events: none;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #tooltip strong {
            color: #253949;
            font-size: 1.4vw;
        }

        #tooltip span {
            color: #253949;
            font-size: 1.2vw;
        }
        
        /* Loading Screen */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(3.8vh);
            border: 0.15vh solid white;
            border-radius: 3.8vh;
            padding: 40px 60px;
            text-align: center;
            z-index: 200;
        }
        
        #loading h3 {
            font-size: 2.6vw;
            color: white;
            margin-bottom: 15px;
            font-family: Arial, Helvetica, sans-serif;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }

        /* Mobile Layout */
        @media screen and (max-width: 768px) {
            .header-center h1 {
                font-size: 5vh;
            }

            .back-button {
                font-size: 2vh;
                padding: 1vh 2vh;
            }

            aside#controls, aside#stats {
                width: 90%;
                min-width: auto;
            }

            aside#controls {
                left: 5%;
                right: 5%;
                top: 90px;
            }

            aside#stats {
                right: 5%;
                top: auto;
                bottom: 100px;
            }

            aside#controls h2, aside#stats h3 {
                font-size: 3vh;
            }

            .control-group label,
            .stat-item {
                font-size: 2vh;
            }

            .control-group select,
            button {
                font-size: 2.2vh;
            }

            aside#info {
                font-size: 1.8vh;
                left: 5%;
                right: 5%;
                text-align: center;
            }

            #loading h3 {
                font-size: 3vh;
            }

            .info-section small {
                font-size: 1.6vh;
            }

            #tooltip {
                font-size: 2vh;
            }

            #tooltip strong {
                font-size: 2.2vh;
            }

            #tooltip span {
                font-size: 1.8vh;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header id="header" role="banner">
        <nav class="header-left" role="navigation" aria-label="Hauptnavigation">
            <a href="/" class="back-button" aria-label="Zur√ºck zur Startseite">
                ‚Üê Zur√ºck
            </a>
        </nav>
        <div class="header-center">
            <h1>üå¶Ô∏è Wetterstation 3D</h1>
        </div>
        <div class="header-right" aria-hidden="true">
        </div>
    </header>

    <main id="container" role="main">
        <div id="loading" role="status" aria-live="polite" aria-label="Ladeanzeige">
            <h3>Lade Wetterdaten...</h3>
            <div class="spinner" aria-hidden="true"></div>
        </div>
        
        <aside id="controls" class="hidden" role="complementary" aria-label="Steuerungsoptionen">
            <h2>üéõÔ∏è Steuerung</h2>
            
            <div class="control-group">
                <label for="senderSelect">Sender ausw√§hlen:</label>
                <select id="senderSelect" aria-label="Wettersender ausw√§hlen">
                    <option value="all">Alle Sender</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="timeRange">Zeitraum (Stunden):</label>
                <select id="timeRange" aria-label="Zeitraum f√ºr Datenabfrage ausw√§hlen">
                    <option value="1">1 Stunde</option>
                    <option value="6">6 Stunden</option>
                    <option value="12">12 Stunden</option>
                    <option value="24" selected>24 Stunden</option>
                    <option value="48">48 Stunden</option>
                    <option value="168">7 Tage</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="visualizationType">Visualisierungstyp:</label>
                <select id="visualizationType" aria-label="Art der 3D-Visualisierung ausw√§hlen">
                    <option value="bars">3D Balken</option>
                    <option value="spheres">Sph√§ren</option>
                    <option value="lines">Linien</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="dataType">Messwert:</label>
                <select id="dataType" aria-label="Messwert f√ºr Visualisierung ausw√§hlen">
                    <option value="temperature">Temperatur (¬∞C)</option>
                    <option value="humidity">Luftfeuchtigkeit (%)</option>
                    <option value="pressure">Luftdruck (hPa)</option>
                </select>
            </div>
            
            <button onclick="loadData()" aria-label="Wetterdaten neu laden">üîÑ Daten neu laden</button>

            <div class="info-section" role="note">
                <small>üí° Die Z-Achse zeigt die echte zeitliche Entwicklung</small>
            </div>
        </aside>
        
        <aside id="stats" class="hidden" role="complementary" aria-label="Datenstatistiken">
            <h3>üìä Statistik</h3>
            <div class="stat-item">
                <span class="stat-label">Sender:</span>
                <span class="stat-value" id="senderCount" aria-live="polite">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Datenpunkte:</span>
                <span class="stat-value" id="dataPointCount" aria-live="polite">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Zeitraum:</span>
                <span class="stat-value" id="timeRangeDisplay" aria-live="polite">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Min. Abstand:</span>
                <span class="stat-value" id="minInterval" aria-live="polite">-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Max. Abstand:</span>
                <span class="stat-value" id="maxInterval" aria-live="polite">-</span>
            </div>
        </aside>
        
        <section id="canvas-container" aria-label="3D-Visualisierung der Wetterdaten"></section>
        
        <aside id="info" class="hidden" role="note" aria-label="Steuerungshinweise">
            üñ±Ô∏è Maus ziehen: Rotieren | üîç Mausrad: Zoom<br>
            üìä Z-Achse = Zeit (echte Zeitabst√§nde)
        </aside>

        <div id="tooltip" class="hidden" role="tooltip" aria-live="polite">
            <strong id="tooltipSender"></strong><br>
            <span id="tooltipValue"></span><br>
            <span id="tooltipTime"></span>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <script>
        /**
         * 3D Weather Visualization Script
         * Erstellt eine interaktive 3D-Visualisierung von Wetterdaten mit Three.js
         */
        
        let scene, camera, renderer;
        let currentData = null;
        let allSendersData = null;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let raycaster, mouse;
        let hoveredObject = null;
        let interactiveObjects = [];
        
        // Performance optimizations
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        let lastRaycastTime = 0;
        const raycastInterval = 16; // ~60fps
        
        // Geometry cache for reuse
        const geometryCache = {
            box: new THREE.BoxGeometry(1.5, 1, 0.3),
            spheres: {} // Cache for different radii
        };
        
        // Scaling constants for 3D objects
        const MIN_HEIGHT = 0.5;
        const MAX_HEIGHT = 40;
        const MIN_RADIUS = 0.3;
        const MAX_RADIUS = 3.0;
        
        /**
         * Debounce-Funktion zur Performance-Optimierung
         * @param {Function} func - Funktion die debounced werden soll
         * @param {number} wait - Wartezeit in Millisekunden
         * @returns {Function} Debounced-Funktion
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        /**
         * Initialisiert die 3D-Szene
         */
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x253949);
            scene.fog = new THREE.Fog(0x253949, 50, 300);
            
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false;
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = false;
            scene.add(directionalLight);
            
            const gridHelper = new THREE.GridHelper(150, 30, 0xffffff, 0x666666);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(40);
            scene.add(axesHelper);
            
            setupControls();
            
            // Debounced resize handler f√ºr bessere Performance
            window.addEventListener('resize', debounce(onWindowResize, 250));
            
            animate();
        }
        
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            // COMBINED mousemove Handler - both dragging and hover
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    // Rotation logic
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    const rotationSpeed = 0.005;
                    
                    const radius = Math.sqrt(
                        camera.position.x ** 2 + 
                        camera.position.y ** 2 + 
                        camera.position.z ** 2
                    );
                    
                    const theta = Math.atan2(camera.position.z, camera.position.x);
                    const phi = Math.acos(camera.position.y / radius);
                    
                    const newTheta = theta + deltaX * rotationSpeed;
                    const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi - deltaY * rotationSpeed));
                    
                    camera.position.x = radius * Math.sin(newPhi) * Math.cos(newTheta);
                    camera.position.y = radius * Math.cos(newPhi);
                    camera.position.z = radius * Math.sin(newPhi) * Math.sin(newTheta);
                    
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                } else {
                    // Hover/Raycasting logic (throttled)
                    onMouseMoveHover(e);
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;
                hideTooltip();
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const direction = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(direction);
            });
        }
        
        function onMouseMoveHover(event) {
            if (isDragging) {
                hideTooltip();
                return;
            }
            
            // Throttle raycasting to ~60fps
            const now = Date.now();
            if (now - lastRaycastTime < raycastInterval) {
                return;
            }
            lastRaycastTime = now;
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(interactiveObjects);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                if (hoveredObject !== object) {
                    if (hoveredObject && hoveredObject.userData.originalEmissive !== undefined) {
                        hoveredObject.material.emissiveIntensity = hoveredObject.userData.originalEmissive;
                    }
                    
                    hoveredObject = object;
                    
                    if (object.material.emissiveIntensity !== undefined) {
                        object.userData.originalEmissive = object.material.emissiveIntensity;
                        object.material.emissiveIntensity = 0.6;
                    }
                    
                    showTooltip(event, object.userData);
                }
            } else {
                if (hoveredObject) {
                    if (hoveredObject.userData.originalEmissive !== undefined) {
                        hoveredObject.material.emissiveIntensity = hoveredObject.userData.originalEmissive;
                    }
                    hoveredObject = null;
                }
                hideTooltip();
            }
        }
        
        function showTooltip(event, data) {
            const tooltip = document.getElementById('tooltip');
            const senderEl = document.getElementById('tooltipSender');
            const valueEl = document.getElementById('tooltipValue');
            const timeEl = document.getElementById('tooltipTime');
            
            senderEl.textContent = data.senderName || 'Unbekannt';
            
            let unit = '';
            if (data.dataType === 'temperature') unit = '¬∞C';
            else if (data.dataType === 'humidity') unit = '%';
            else if (data.dataType === 'pressure') unit = ' hPa';
            
            valueEl.textContent = `${data.dataType === 'temperature' ? 'Temperatur' : 
                                    data.dataType === 'humidity' ? 'Luftfeuchtigkeit' : 
                                    'Luftdruck'}: ${data.value.toFixed(2)}${unit}`;
            
            if (data.timestamp) {
                const date = new Date(data.timestamp * 1000);
                timeEl.textContent = date.toLocaleString('de-DE', {
                    day: '2-digit',
                    month: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
            tooltip.classList.remove('hidden');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').classList.add('hidden');
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastFrameTime;
            
            // Limit to target FPS
            if (deltaTime >= frameInterval) {
                renderer.render(scene, camera);
                lastFrameTime = currentTime - (deltaTime % frameInterval);
            }
        }
        
        async function loadData() {
            const hours = document.getElementById('timeRange').value;
            document.getElementById('loading').classList.remove('hidden');
            
            try {
                const response = await fetch(`/api/weather/visualization/data?hours=${hours}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                allSendersData = data;
                populateSenderSelect(data.senders);
                
                const selectedSender = document.getElementById('senderSelect').value;
                currentData = filterDataBySender(data, selectedSender);
                
                updateStats(currentData);
                visualizeData(currentData);
                
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('controls').classList.remove('hidden');
                document.getElementById('stats').classList.remove('hidden');
                document.getElementById('info').classList.remove('hidden');
                
            } catch (error) {
                console.error('Fehler beim Laden der Daten:', error);
                
                // Bessere Benutzer-Feedback
                const loadingEl = document.getElementById('loading');
                const loadingText = loadingEl.querySelector('h3');
                loadingText.textContent = '‚ùå Fehler beim Laden';
                loadingEl.querySelector('.spinner').style.display = 'none';
                
                // Error-Details f√ºr Entwickler
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    loadingText.textContent = '‚ùå Netzwerkfehler - Server nicht erreichbar';
                } else {
                    loadingText.textContent = `‚ùå Fehler: ${error.message}`;
                }
                
                // Retry-Option nach 5 Sekunden
                setTimeout(() => {
                    if (document.getElementById('loading').classList.contains('hidden') === false) {
                        loadingText.textContent = 'Lade Wetterdaten...';
                        loadingEl.querySelector('.spinner').style.display = 'block';
                    }
                }, 5000);
            }
        }
        
        function populateSenderSelect(senders) {
            const select = document.getElementById('senderSelect');
            const currentValue = select.value;
            
            select.innerHTML = '<option value="all">Alle Sender</option>';
            
            senders.forEach(sender => {
                const option = document.createElement('option');
                option.value = sender.sender.sender_id;
                option.textContent = `${sender.sender.name} (${sender.sender.sender_id})`;
                select.appendChild(option);
            });
            
            if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
                select.value = currentValue;
            }
        }
        
        function filterDataBySender(data, senderId) {
            if (senderId === 'all') {
                return data;
            }
            
            const filteredSenders = data.senders.filter(s => s.sender.sender_id === senderId);
            
            return {
                senders: filteredSenders,
                hours: data.hours,
                totalSenders: filteredSenders.length,
                totalDataPoints: filteredSenders.reduce((sum, s) => sum + s.dataPoints.length, 0)
            };
        }
        
        function updateStats(data) {
            document.getElementById('senderCount').textContent = data.totalSenders;
            document.getElementById('dataPointCount').textContent = data.totalDataPoints;
            document.getElementById('timeRangeDisplay').textContent = data.hours + 'h';
            
            let minInterval = Infinity;
            let maxInterval = 0;
            
            data.senders.forEach(sender => {
                const points = sender.dataPoints;
                for (let i = 1; i < points.length; i++) {
                    const interval = points[i].unix_timestamp - points[i - 1].unix_timestamp;
                    minInterval = Math.min(minInterval, interval);
                    maxInterval = Math.max(maxInterval, interval);
                }
            });
            
            if (minInterval === Infinity) minInterval = 0;
            
            document.getElementById('minInterval').textContent = formatInterval(minInterval);
            document.getElementById('maxInterval').textContent = formatInterval(maxInterval);
        }
        
        function formatInterval(seconds) {
            if (seconds < 60) return `${seconds}s`;
            if (seconds < 3600) return `${Math.round(seconds / 60)}min`;
            return `${Math.round(seconds / 3600)}h`;
        }
        
        function visualizeData(data) {
            interactiveObjects = [];
            const objectsToRemove = [];
            scene.children.forEach(child => {
                if (child.type === 'Mesh' || child.type === 'Line' || child.type === 'Sprite') {
                    objectsToRemove.push(child);
                }
            });
            
            objectsToRemove.forEach(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                scene.remove(obj);
            });
            
            const vizType = document.getElementById('visualizationType').value;
            const dataType = document.getElementById('dataType').value;
            
            const senders = data.senders;
            const senderSpacing = 25;
            
            let minValue = Infinity;
            let maxValue = -Infinity;
            
            senders.forEach(sender => {
                sender.dataPoints.forEach(point => {
                    const value = point[dataType] || 0;
                    minValue = Math.min(minValue, value);
                    maxValue = Math.max(maxValue, value);
                });
            });
            
            if (senders.length > 0) {
                const leftX = ((0 - (senders.length - 1) / 2) * senderSpacing) - 8;
                addYAxisLabels(leftX, minValue, maxValue, dataType);
            }
            
            senders.forEach((sender, senderIndex) => {
                const dataPoints = sender.dataPoints;
                if (dataPoints.length === 0) return;
                
                const xOffset = (senderIndex - (senders.length - 1) / 2) * senderSpacing;
                
                createTextLabel(sender.sender.name, xOffset, -5, 0);
                
                const timestamps = dataPoints.map(p => p.unix_timestamp || p.unix);
                const minTime = Math.min(...timestamps);
                const maxTime = Math.max(...timestamps);
                const timeRange = maxTime - minTime;
                
                const zRange = 60;
                const timeScale = timeRange > 0 ? zRange / timeRange : 1;
                
                dataPoints.forEach((point, pointIndex) => {
                    const value = point[dataType] || 0;
                    const timestamp = point.unix_timestamp || point.unix;
                    const zPosition = ((timestamp - minTime) * timeScale) - (zRange / 2);
                    
                    const metadata = {
                        senderName: sender.sender.name,
                        value: value,
                        dataType: dataType,
                        timestamp: timestamp
                    };
                    
                    if (vizType === 'bars') {
                        createBar(value, dataType, xOffset, zPosition, metadata, minValue, maxValue);
                    } else if (vizType === 'spheres') {
                        createSphere(value, dataType, xOffset, zPosition, metadata, minValue, maxValue);
                    } else if (vizType === 'lines' && pointIndex > 0) {
                        const prevPoint = dataPoints[pointIndex - 1];
                        const prevValue = prevPoint[dataType] || 0;
                        const prevTimestamp = prevPoint.unix_timestamp || prevPoint.unix;
                        const prevZ = ((prevTimestamp - minTime) * timeScale) - (zRange / 2);
                        createLine(prevValue, value, dataType, xOffset, prevZ, zPosition, minValue, maxValue);
                    }
                });
                
                addTimeMarkers(xOffset, minTime, maxTime, zRange);
            });
        }
        
        function addYAxisLabels(x, minValue, maxValue, dataType) {
            const labelCount = 6;
            const range = maxValue - minValue;
            const step = range / (labelCount - 1);
            
            let unit = '';
            if (dataType === 'temperature') unit = '¬∞C';
            else if (dataType === 'humidity') unit = '%';
            else if (dataType === 'pressure') unit = 'hPa';
            
            for (let i = 0; i < labelCount; i++) {
                const value = minValue + (step * i);
                // Use the same scaling function as for objects
                const height = getScaledHeight(value, minValue, maxValue);
                const y = height;
                
                // Round to integer for all data types
                let displayValue = Math.round(value);
                createSmallLabel(`${displayValue}${unit}`, x, y, 0, 0.8);
            }
        }
        
        function addTimeMarkers(x, minTime, maxTime, zRange) {
            const markerCount = 5;
            const timeStep = (maxTime - minTime) / (markerCount - 1);
            
            for (let i = 0; i < markerCount; i++) {
                const timestamp = minTime + (timeStep * i);
                const z = (i / (markerCount - 1)) * zRange - (zRange / 2);
                
                const date = new Date(timestamp * 1000);
                const timeStr = date.toLocaleTimeString('de-DE', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                createSmallLabel(timeStr, x + 3, 0, z, 1);
            }
        }
        
        function createTextLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'Bold 48px Arial';
            context.fillStyle = '#253949';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(12, 3, 1);
            scene.add(sprite);
        }
        
        function createSmallLabel(text, x, y, z, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;

            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'Bold 56px Arial';
            context.fillStyle = '#253949';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(8 * scale, 2 * scale, 1);
            scene.add(sprite);
        }
        
        function createBar(value, dataType, x, z, metadata, minValue, maxValue) {
            const height = getScaledHeight(value, minValue, maxValue);
            const geometry = new THREE.BoxGeometry(1.5, height, 0.3);
            const material = new THREE.MeshPhongMaterial({
                color: getColorForValue(value, dataType),
                emissive: getColorForValue(value, dataType),
                emissiveIntensity: 0.3,
                shininess: 30
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, height / 2, z);
            mesh.userData = metadata;
            scene.add(mesh);
            interactiveObjects.push(mesh);
        }
        
        function createSphere(value, dataType, x, z, metadata, minValue, maxValue) {
            const radius = getScaledRadius(value, minValue, maxValue);
            const height = getScaledHeight(value, minValue, maxValue);
            const cacheKey = Math.round(radius * 10); // Round to 0.1
            
            // Get geometry from cache or create new
            if (!geometryCache.spheres[cacheKey]) {
                geometryCache.spheres[cacheKey] = new THREE.SphereGeometry(cacheKey / 10, 8, 8);
            }
            
            const geometry = geometryCache.spheres[cacheKey];
            const material = new THREE.MeshPhongMaterial({
                color: getColorForValue(value, dataType),
                emissive: getColorForValue(value, dataType),
                emissiveIntensity: 0.4,
                shininess: 50
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, height * 0.5, z);
            mesh.userData = metadata;
            scene.add(mesh);
            interactiveObjects.push(mesh);
        }
        
        function createLine(prevValue, value, dataType, x, prevZ, z, minValue, maxValue) {
            const prevHeight = getScaledHeight(prevValue, minValue, maxValue);
            const height = getScaledHeight(value, minValue, maxValue);
            
            const points = [];
            points.push(new THREE.Vector3(x, prevHeight * 0.5, prevZ));
            points.push(new THREE.Vector3(x, height * 0.5, z));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: getColorForValue(value, dataType),
                linewidth: 3
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }
        
        function getScaledHeight(value, minValue, maxValue) {
            // Linear scaling to a fixed range
            // Avoid division by zero
            if (maxValue === minValue) {
                return MIN_HEIGHT;
            }
            
            // Normalize value to 0-1 range, then scale to MIN_HEIGHT to MAX_HEIGHT
            const normalized = (value - minValue) / (maxValue - minValue);
            const height = normalized * (MAX_HEIGHT - MIN_HEIGHT) + MIN_HEIGHT;
            
            return Math.max(height, MIN_HEIGHT);
        }
        
        function getScaledRadius(value, minValue, maxValue) {
            // Linear scaling for radius
            // Avoid division by zero
            if (maxValue === minValue) {
                return MIN_RADIUS;
            }
            
            // Normalize value to 0-1 range, then scale to MIN_RADIUS to MAX_RADIUS
            const normalized = (value - minValue) / (maxValue - minValue);
            const radius = normalized * (MAX_RADIUS - MIN_RADIUS) + MIN_RADIUS;
            
            return Math.max(radius, MIN_RADIUS);
        }
        
        function getColorForValue(value, dataType) {
            if (dataType === 'temperature') {
                const normalized = Math.max(0, Math.min(1, (value + 10) / 50));
                return new THREE.Color(normalized, 0.3, 1 - normalized);
            } else if (dataType === 'humidity') {
                const normalized = Math.max(0, Math.min(1, value / 100));
                return new THREE.Color(0.4, 0.6 + normalized * 0.4, 1);
            } else if (dataType === 'pressure') {
                const normalized = Math.max(0, Math.min(1, (value - 950) / 100));
                return new THREE.Color(normalized * 0.6 + 0.4, 1, 0.4);
            }
            return new THREE.Color(1, 1, 1);
        }
        
        document.getElementById('senderSelect').addEventListener('change', () => {
            if (allSendersData) {
                const selectedSender = document.getElementById('senderSelect').value;
                currentData = filterDataBySender(allSendersData, selectedSender);
                updateStats(currentData);
                visualizeData(currentData);
            }
        });
        
        document.getElementById('timeRange').addEventListener('change', loadData);
        
        document.getElementById('visualizationType').addEventListener('change', () => {
            if (currentData) visualizeData(currentData);
        });
        
        document.getElementById('dataType').addEventListener('change', () => {
            if (currentData) visualizeData(currentData);
        });
        
        /**
         * Keyboard Navigation Support
         * Erm√∂glicht Navigation mit Pfeiltasten und Shortcuts
         */
        document.addEventListener('keydown', (e) => {
            // Prevent default for arrow keys to avoid page scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            
            const rotationSpeed = 0.1;
            const zoomSpeed = 1.1;
            
            switch(e.key) {
                case 'ArrowLeft':
                    // Rotate left
                    const radiusLeft = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                    const angleLeft = Math.atan2(camera.position.z, camera.position.x) + rotationSpeed;
                    camera.position.x = radiusLeft * Math.cos(angleLeft);
                    camera.position.z = radiusLeft * Math.sin(angleLeft);
                    camera.lookAt(0, 0, 0);
                    break;
                    
                case 'ArrowRight':
                    // Rotate right
                    const radiusRight = Math.sqrt(camera.position.x ** 2 + camera.position.z ** 2);
                    const angleRight = Math.atan2(camera.position.z, camera.position.x) - rotationSpeed;
                    camera.position.x = radiusRight * Math.cos(angleRight);
                    camera.position.z = radiusRight * Math.sin(angleRight);
                    camera.lookAt(0, 0, 0);
                    break;
                    
                case 'ArrowUp':
                    // Zoom in
                    camera.position.multiplyScalar(1 / zoomSpeed);
                    break;
                    
                case 'ArrowDown':
                    // Zoom out
                    camera.position.multiplyScalar(zoomSpeed);
                    break;
                    
                case 'r':
                case 'R':
                    // Reload data (Shortcut)
                    if (!e.ctrlKey) loadData();
                    break;
                    
                case 'Escape':
                    // Reset camera position
                    camera.position.set(50, 50, 50);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        });
        
        // Focus management f√ºr bessere Accessibility
        const controlsElement = document.getElementById('controls');
        
        document.getElementById('senderSelect').addEventListener('focus', () => {
            controlsElement.setAttribute('aria-expanded', 'true');
        });
        
        document.getElementById('senderSelect').addEventListener('blur', () => {
            controlsElement.setAttribute('aria-expanded', 'false');
        });
        
        initScene();
        loadData();
    </script>
</body>
</html>